// Code generated by MockGen. DO NOT EDIT.
// Source: ./cmd.go

// Package cmd is a generated GoMock package.
package cmd

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockGithub is a mock of Github interface.
type MockGithub struct {
	ctrl     *gomock.Controller
	recorder *MockGithubMockRecorder
}

// MockGithubMockRecorder is the mock recorder for MockGithub.
type MockGithubMockRecorder struct {
	mock *MockGithub
}

// NewMockGithub creates a new mock instance.
func NewMockGithub(ctrl *gomock.Controller) *MockGithub {
	mock := &MockGithub{ctrl: ctrl}
	mock.recorder = &MockGithubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGithub) EXPECT() *MockGithubMockRecorder {
	return m.recorder
}

// GetAllRepos mocks base method.
func (m *MockGithub) GetAllRepos() ([]GithubRepository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllRepos")
	ret0, _ := ret[0].([]GithubRepository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllRepos indicates an expected call of GetAllRepos.
func (mr *MockGithubMockRecorder) GetAllRepos() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllRepos", reflect.TypeOf((*MockGithub)(nil).GetAllRepos))
}

// GetCommitHash mocks base method.
func (m *MockGithub) GetCommitHash(name, branch string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitHash", name, branch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitHash indicates an expected call of GetCommitHash.
func (mr *MockGithubMockRecorder) GetCommitHash(name, branch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitHash", reflect.TypeOf((*MockGithub)(nil).GetCommitHash), name, branch)
}

// GetPrimaryLanguageForRepo mocks base method.
func (m *MockGithub) GetPrimaryLanguageForRepo(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPrimaryLanguageForRepo", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPrimaryLanguageForRepo indicates an expected call of GetPrimaryLanguageForRepo.
func (mr *MockGithubMockRecorder) GetPrimaryLanguageForRepo(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPrimaryLanguageForRepo", reflect.TypeOf((*MockGithub)(nil).GetPrimaryLanguageForRepo), name)
}

// MockFilesystem is a mock of Filesystem interface.
type MockFilesystem struct {
	ctrl     *gomock.Controller
	recorder *MockFilesystemMockRecorder
}

// MockFilesystemMockRecorder is the mock recorder for MockFilesystem.
type MockFilesystemMockRecorder struct {
	mock *MockFilesystem
}

// NewMockFilesystem creates a new mock instance.
func NewMockFilesystem(ctrl *gomock.Controller) *MockFilesystem {
	mock := &MockFilesystem{ctrl: ctrl}
	mock.recorder = &MockFilesystemMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFilesystem) EXPECT() *MockFilesystemMockRecorder {
	return m.recorder
}

// CreateDirectory mocks base method.
func (m *MockFilesystem) CreateDirectory(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDirectory", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateDirectory indicates an expected call of CreateDirectory.
func (mr *MockFilesystemMockRecorder) CreateDirectory(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDirectory", reflect.TypeOf((*MockFilesystem)(nil).CreateDirectory), path)
}

// Exists mocks base method.
func (m *MockFilesystem) Exists(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockFilesystemMockRecorder) Exists(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockFilesystem)(nil).Exists), path)
}

// ListDirectories mocks base method.
func (m *MockFilesystem) ListDirectories(path string, depth int) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirectories", path, depth)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDirectories indicates an expected call of ListDirectories.
func (mr *MockFilesystemMockRecorder) ListDirectories(path, depth interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirectories", reflect.TypeOf((*MockFilesystem)(nil).ListDirectories), path, depth)
}

// MockTUI is a mock of TUI interface.
type MockTUI struct {
	ctrl     *gomock.Controller
	recorder *MockTUIMockRecorder
}

// MockTUIMockRecorder is the mock recorder for MockTUI.
type MockTUIMockRecorder struct {
	mock *MockTUI
}

// NewMockTUI creates a new mock instance.
func NewMockTUI(ctrl *gomock.Controller) *MockTUI {
	mock := &MockTUI{ctrl: ctrl}
	mock.recorder = &MockTUIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTUI) EXPECT() *MockTUIMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockTUI) Handle(repository GithubRepository, state RepositoryState) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", repository, state)
	ret0, _ := ret[0].(error)
	return ret0
}

// Handle indicates an expected call of Handle.
func (mr *MockTUIMockRecorder) Handle(repository, state interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockTUI)(nil).Handle), repository, state)
}

// MockGit is a mock of Git interface.
type MockGit struct {
	ctrl     *gomock.Controller
	recorder *MockGitMockRecorder
}

// MockGitMockRecorder is the mock recorder for MockGit.
type MockGitMockRecorder struct {
	mock *MockGit
}

// NewMockGit creates a new mock instance.
func NewMockGit(ctrl *gomock.Controller) *MockGit {
	mock := &MockGit{ctrl: ctrl}
	mock.recorder = &MockGitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGit) EXPECT() *MockGitMockRecorder {
	return m.recorder
}

// CloneRepo mocks base method.
func (m *MockGit) CloneRepo(r GithubRepository, path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloneRepo", r, path)
	ret0, _ := ret[0].(error)
	return ret0
}

// CloneRepo indicates an expected call of CloneRepo.
func (mr *MockGitMockRecorder) CloneRepo(r, path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloneRepo", reflect.TypeOf((*MockGit)(nil).CloneRepo), r, path)
}

// GetBranchName mocks base method.
func (m *MockGit) GetBranchName(path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranchName", path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranchName indicates an expected call of GetBranchName.
func (mr *MockGitMockRecorder) GetBranchName(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranchName", reflect.TypeOf((*MockGit)(nil).GetBranchName), path)
}

// GetCommitHashes mocks base method.
func (m *MockGit) GetCommitHashes(path string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitHashes", path)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitHashes indicates an expected call of GetCommitHashes.
func (mr *MockGitMockRecorder) GetCommitHashes(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitHashes", reflect.TypeOf((*MockGit)(nil).GetCommitHashes), path)
}

// HasMergeConflicts mocks base method.
func (m *MockGit) HasMergeConflicts(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasMergeConflicts", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasMergeConflicts indicates an expected call of HasMergeConflicts.
func (mr *MockGitMockRecorder) HasMergeConflicts(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasMergeConflicts", reflect.TypeOf((*MockGit)(nil).HasMergeConflicts), path)
}

// HasUncommittedChanges mocks base method.
func (m *MockGit) HasUncommittedChanges(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasUncommittedChanges", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasUncommittedChanges indicates an expected call of HasUncommittedChanges.
func (mr *MockGitMockRecorder) HasUncommittedChanges(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasUncommittedChanges", reflect.TypeOf((*MockGit)(nil).HasUncommittedChanges), path)
}

// PullLatest mocks base method.
func (m *MockGit) PullLatest(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PullLatest", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// PullLatest indicates an expected call of PullLatest.
func (mr *MockGitMockRecorder) PullLatest(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullLatest", reflect.TypeOf((*MockGit)(nil).PullLatest), path)
}
